{"Name":"MailKit","Id":3452,"Alias":"mailkit","Description":"MailKit is a cross-platform mail client library built on top of [MimeKit](https://github.com/jstedfast/MimeKit).\n\n## Features\n\n* SASL Authentication\n  * CRAM-MD5\n  * DIGEST-MD5\n  * LOGIN\n  * NTLM\n  * PLAIN\n  * SCRAM-SHA-1\n  * XOAUTH2 (partial support - you need to fetch the auth tokens yourself)\n* SMTP Client\n  * Supports all of the SASL mechanisms listed above.\n  * Supports SSL-wrapped connections via the \"smtps\" protocol.\n  * Supports client SSL/TLS certificates.\n  * Supports the following extensions: STARTTLS, SIZE, DSN, 8BITMIME, PIPELINING, BINARYMIME, SMTPUTF8\n  * All APIs are cancellable.\n  * Async APIs are available.\n* POP3 Client\n  * Supports all of the SASL mechanisms listed above.\n  * Also supports authentication via APOP and USER/PASS.\n  * Supports SSL-wrapped connections via the \"pops\" protocol.\n  * Supports client SSL/TLS certificates.\n  * Supports the following extensions: STLS, UIDL, PIPELINING, UTF8, LANG\n  * All APIs are cancellable.\n  * Async APIs are available.\n* IMAP4 Client\n  * Supports all of the SASL mechanisms listed above.\n  * Supports SSL-wrapped connections via the \"imaps\" protocol.\n  * Supports client SSL/TLS certificates.\n  * Supports the following extensions:\n    * ACL\n    * QUOTA\n    * LITERAL+\n    * IDLE\n    * NAMESPACE\n    * ID\n    * CHILDREN\n    * LOGINDISABLED\n    * STARTTLS\n    * MULTIAPPEND\n    * UNSELECT\n    * UIDPLUS\n    * CONDSTORE\n    * ESEARCH\n    * SASL-IR\n    * COMPRESS\n    * WITHIN\n    * ENABLE\n    * QRESYNC\n    * SORT\n    * THREAD\n    * ESORT (partial)\n    * SPECIAL-USE\n    * SEARCH=FUZZY (partial)\n    * MOVE\n    * UTF8=ACCEPT\n    * UTF8=ONLY\n    * XLIST\n    * X-GM-EXT1 (X-GM-MSGID, X-GM-THRID, X-GM-RAW and X-GM-LABELS)\n  * All APIs are cancellable.\n  * Async APIs are available.\n* Client-side sorting and threading of messages.\n","Version":"1.16.0","Summary":"Send and receive emails via SMTP, IMAP, and POP3. Encrypt or sign emails via OpenPGP, S/MIME and DKIM.","QuickStart":"## Getting Started\n### Sending Messages\n\nOne of the more common operations that MailKit is meant for is sending email messages.\n\n```csharp\nusing System;\n\nusing MailKit.Net.Smtp;\nusing MailKit;\nusing MimeKit;\n\nnamespace TestClient {\n\tclass Program\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tvar message = new MimeMessage ();\n\t\t\tmessage.From.Add (new MailboxAddress (\"Joey Tribbiani\", \"joey@friends.com\"));\n\t\t\tmessage.To.Add (new MailboxAddress (\"Mrs. Chanandler Bong\", \"chandler@friends.com\"));\n\t\t\tmessage.Subject = \"How you doin\u0027?\";\n\n\t\t\tmessage.Body = new TextPart (\"plain\") {\n\t\t\t\tText = @\"Hey Chandler,\n\nI just wanted to let you know that Monica and I were going to go play some paintball, you in?\n\n-- Joey\"\n\t\t\t};\n\n\t\t\tusing (var client = new SmtpClient ()) {\n\t\t\t\t// For demo-purposes, accept all SSL certificates (in case the server supports STARTTLS)\n\t\t\t\tclient.ServerCertificateValidationCallback = (s,c,h,e) =\u003e true;\n\n\t\t\t\tclient.Connect (\"smtp.friends.com\", 587, false);\n\n\t\t\t\t// Note: since we don\u0027t have an OAuth2 token, disable\n\t\t\t\t// the XOAUTH2 authentication mechanism.\n\t\t\t\tclient.AuthenticationMechanisms.Remove (\"XOAUTH2\");\n\n\t\t\t\t// Note: only needed if the SMTP server requires authentication\n\t\t\t\tclient.Authenticate (\"joey\", \"password\");\n\n\t\t\t\tclient.Send (message);\n\t\t\t\tclient.Disconnect (true);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## Retrieving Messages (via Pop3)\n\nOne of the other main uses of MailKit is retrieving messages from pop3 servers.\n\n```csharp\nusing System;\n\nusing MailKit.Net.Pop3;\nusing MailKit;\nusing MimeKit;\n\nnamespace TestClient {\n\tclass Program\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tusing (var client = new Pop3Client ()) {\n\t\t\t\t// For demo-purposes, accept all SSL certificates (in case the server supports STARTTLS)\n\t\t\t\tclient.ServerCertificateValidationCallback = (s,c,h,e) =\u003e true;\n\n\t\t\t\tclient.Connect (\"pop.friends.com\", 110, false);\n\n\t\t\t\t// Note: since we don\u0027t have an OAuth2 token, disable\n\t\t\t\t// the XOAUTH2 authentication mechanism.\n\t\t\t\tclient.AuthenticationMechanisms.Remove (\"XOAUTH2\");\n\n\t\t\t\tclient.Authenticate (\"joey\", \"password\");\n\n\t\t\t\tfor (int i = 0; i \u003c client.Count; i++) {\n\t\t\t\t\tvar message = client.GetMessage (i);\n\t\t\t\t\tConsole.WriteLine (\"Subject: {0}\", message.Subject);\n\t\t\t\t}\n\n\t\t\t\tclient.Disconnect (true);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n## Using IMAP\n\nMore important than POP3 support is the IMAP support. Here\u0027s a simple use-case of retreiving messages from an IMAP server:\n\n```csharp\nusing System;\n\nusing MailKit.Net.Imap;\nusing MailKit.Search;\nusing MailKit;\nusing MimeKit;\n\nnamespace TestClient {\n\tclass Program\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tusing (var client = new ImapClient ()) {\n\t\t\t\t// For demo-purposes, accept all SSL certificates\n\t\t\t\tclient.ServerCertificateValidationCallback = (s,c,h,e) =\u003e true;\n\n\t\t\t\tclient.Connect (\"imap.friends.com\", 993, true);\n\n\t\t\t\t// Note: since we don\u0027t have an OAuth2 token, disable\n\t\t\t\t// the XOAUTH2 authentication mechanism.\n\t\t\t\tclient.AuthenticationMechanisms.Remove (\"XOAUTH2\");\n\n\t\t\t\tclient.Authenticate (\"joey\", \"password\");\n\n\t\t\t\t// The Inbox folder is always available on all IMAP servers...\n\t\t\t\tvar inbox = client.Inbox;\n\t\t\t\tinbox.Open (FolderAccess.ReadOnly);\n\n\t\t\t\tConsole.WriteLine (\"Total messages: {0}\", inbox.Count);\n\t\t\t\tConsole.WriteLine (\"Recent messages: {0}\", inbox.Recent);\n\n\t\t\t\tfor (int i = 0; i \u003c inbox.Count; i++) {\n\t\t\t\t\tvar message = inbox.GetMessage (i);\n\t\t\t\t\tConsole.WriteLine (\"Subject: {0}\", message.Subject);\n\t\t\t\t}\n\n\t\t\t\tclient.Disconnect (true);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nHowever, you probably want to do more complicated things with IMAP such as fetching summary information\nso that you can display a list of messages in a mail client without having to first download all of the\nmessages from the server:\n\n```csharp\nforeach (var summary in inbox.Fetch (0, -1, MessageSummaryItems.Full | MessageSummaryItems.UniqueId)) {\n\tConsole.WriteLine (\"[summary] {0:D2}: {1}\", summary.Index, summary.Envelope.Subject);\n}\n```\n\nThe results of a Fetch command can also be used to download individual MIME parts rather\nthan downloading the entire message. For example:\n\n```csharp\nforeach (var summary in inbox.Fetch (0, -1, MessageSummaryItems.UniqueId | MessageSummaryItems.BodyStructure)) {\n    if (summary.TextBody != null) {\n\t// this will download *just* the text/plain part\n\tvar text = inbox.GetBodyPart (summary.UniqueId, summary.TextBody);\n    }\n    \n    if (summary.HtmlBody != null) {\n        // this will download *just* the text/html part\n\tvar html = inbox.GetBodyPart (summary.UniqueId, summary.HtmlBody);\n    }\n    \n    // if you\u0027d rather grab, say, an image attachment... it might look something like this:\n    if (summary.Body is BodyPartMultipart) {\n        var multipart = (BodyPartMultipart) summary.Body;\n        \n        var attachment = multipart.BodyParts.OfType\u003cBodyPartBasic\u003e ().FirstOrDefault (x =\u003e x.FileName == \"logo.jpg\");\n        if (attachment != null) {\n            // this will download *just* the attachment\n            var part = inbox.GetBodyPart (summary.UniqueId, attachment);\n        }\n    }\n}\n```\n\nYou may also be interested in sorting and searching...\n\n```csharp\n// let\u0027s search for all messages received after Jan 12, 2013 with \"MailKit\" in the subject...\nvar query = SearchQuery.DeliveredAfter (DateTime.Parse (\"2013-01-12\"))\n    .And (SearchQuery.SubjectContains (\"MailKit\")).And (SearchQuery.Seen);\n\nforeach (var uid in inbox.Search (query)) {\n\tvar message = inbox.GetMessage (uid);\n\tConsole.WriteLine (\"[match] {0}: {1}\", uid, message.Subject);\n}\n\n// let\u0027s do the same search, but this time sort them in reverse arrival order\nvar orderBy = new [] { OrderBy.ReverseArrival };\nforeach (var uid in inbox.Search (query, orderBy)) {\n\tvar message = inbox.GetMessage (uid);\n\tConsole.WriteLine (\"[match] {0}: {1}\", uid, message.Subject);\n}\n\n// you\u0027ll notice that the orderBy argument is an array... this is because you\n// can actually sort the search results based on multiple columns:\norderBy = new [] { OrderBy.ReverseArrival, OrderBy.Subject };\nforeach (var uid in inbox.Search (query, orderBy)) {\n\tvar message = inbox.GetMessage (uid);\n\tConsole.WriteLine (\"[match] {0}: {1}\", uid, message.Subject);\n}\n```\n\nOf course, instead of downloading the message, you could also fetch the summary information for the matching messages\nor do any of a number of other things with the UIDs that are returned.\n\nHow about navigating folders? MailKit can do that, too:\n\n```csharp\n// Get the first personal namespace and list the toplevel folders under it.\nvar personal = client.GetFolder (client.PersonalNamespaces[0]);\nforeach (var folder in personal.GetSubfolders (false))\n\tConsole.WriteLine (\"[folder] {0}\", folder.Name);\n```\n\nIf the IMAP server supports the SPECIAL-USE or the XLIST (GMail) extension, you can get ahold of\nthe pre-defined All, Drafts, Flagged (aka Important), Junk, Sent, Trash, etc folders like this:\n\n```csharp\nif ((client.Capabilities \u0026 (ImapCapabilities.SpecialUse | ImapCapabilities.XList)) != 0) {\n\tvar drafts = client.GetFolder (SpecialFolder.Drafts);\n} else {\n\t// maybe check the user\u0027s preferences for the Drafts folder?\n}\n```\n\nIn cases where the IMAP server does *not* support the SPECIAL-USE or XLIST extensions, you\u0027ll have to\ncome up with your own heuristics for getting the Sent, Drafts, Trash, etc folders. For example, you\nmight use logic similar to this:\n\n```csharp\nstatic string[] CommonSentFolderNames = { \"Sent Items\", \"Sent Mail\", /* maybe add some translated names */ };\n\nstatic IFolder GetSentFolder (ImapClient client, CancellationToken cancellationToken)\n{\n    var personal = client.GetFolder (client.PersonalNamespaces[0]);\n\n    foreach (var folder in personal.GetSubfolders (false, cancellationToken)) {\n        foreach (var name in CommonSentFolderNames) {\n            if (folder.Name == commonName)\n                return folder;\n        }\n    }\n\n    return null;\n}\n```\n\nUsing LINQ, you could simplify this down to something more like this:\n\n```csharp\nstatic string[] CommonSentFolderNames = { \"Sent Items\", \"Sent Mail\", /* maybe add some translated names */ };\n\nstatic IFolder GetSentFolder (ImapClient client, CancellationToken cancellationToken)\n{\n    var personal = client.GetFolder (client.PersonalNamespaces[0]);\n    \n    return personal.GetSubfolders (false, cancellationToken).FirstOrDefault (x =\u003e CommonSentFolderNames.Contains (x.Name));\n}\n```\n\nAnother option might be to allow the user of your application to configure which folder he or she wants to use as their Sent folder, Drafts folder, Trash folder, etc.\n\nHow you handle this is up to you.\n\n## Donate\n\nMailKit is a personal open source project that I have put thousands of hours into perfecting with the\ngoal of making it not only the very best email framework for .NET, but the best email framework for\nany programming language. I need your help to achieve this.\n\n\u003ca href=\"http://www.pledgie.com/campaigns/29300\" target=\"_blank\"\u003e\n  \u003cimg src=\"http://www.pledgie.com/campaigns/29300.png?skin_name=chrome\"\n       alt=\"Click here to lend your support to MimeKit and MailKit by making a donation via pledgie.com!\"\n       border=\"0\" /\u003e\n\u003c/a\u003e\n\n## Reporting Bugs\n\nHave a bug or a feature request? [Please open a new issue](https://github.com/jstedfast/MailKit/issues).\n\nBefore opening a new issue, please search for existing issues to avoid submitting duplicates.\n\n## Documentation\n\nAPI documentation can be found at [http://mimekit.net/docs](http://mimekit.net/docs).\n\nA copy of the xml formatted API documentation is also included in the NuGet and/or\nXamarin Component package.\n","Hash":"43f5be2c52866aa53499765e2cb722a1","TargetPlatforms":["ios","ios-unified","android"],"TrialHash":null}